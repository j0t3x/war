{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///war.min.js","webpack:///webpack/bootstrap 06e7dfc74c2f8af9cf08","webpack:///./src/index.js","webpack:///./src/war/connectionManager.js","webpack:///./src/war/connection.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","war","connection","connectionManager","globalHeaders","methods","connections","i","length","method","connID","data","send","bind","prototype","setGlobalHeaders","h","header","hasOwnProperty","startAndSend","confConnection","url","generateConnectionID","s4","Math","floor","random","toString","substring","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","encoding","async","tempHeaders","xhr","checkXHR","FormData","lastTimeOfUse","setListeners","headers","formatAsFormData","open","_addTempHeader","setNowLastTimeOfUse","member","append","date","Date","now","addTxtFileFromString","name","str","blob","Blob","type","addImgFileFromArr","arr","Array","addTempHeader","setRequestHeader","setEncoding","enc","window","XMLHttpRequest","ActiveXObject","e","addEventListener","readystatechange","_progress","_load","_error","_abort","context","readyState","status","_response","responseText","response","percentComplete","lengthComputable","total","progress","load","error","abort"],"mappings":"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","file":"war.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"war\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"war\"] = factory();\n\telse\n\t\troot[\"war\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"war\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"war\"] = factory();\n\telse\n\t\troot[\"war\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar war = __webpack_require__(1);\n\twar = new war();\n\tmodule.exports = war;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// onloadstart\tloadstart\n\t// onprogress\tprogress\n\t// onabort\tabort\n\t// onerror\terror\n\t// onload\tload\n\t// ontimeout\ttimeout\n\t// onloadend\tloadend\n\t\n\tvar connection = __webpack_require__(2);\n\t\n\tvar connectionManager = function(){\n\t\n\t  this.globalHeaders = {};\n\t  this.methods = [ 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD' ];\n\t  this.connections = {};\n\t\n\t  for (var i = 0; i < this.methods.length; i++) {\n\t    this[ this.methods[i] ] = (function( method ){\n\t      return function( connID, data ){\n\t        this.send( connID, method, data );\n\t      };\n\t    }.bind(this))( this.methods[i] );\n\t  }\n\t\n\t};\n\t\n\tconnectionManager.prototype.setGlobalHeaders = function( h ){\n\t\n\t  if( !h )\n\t    throw 'grow a pair... name, value needed to set a temporal header for this connection';\n\t\n\t  for (var header in h) {\n\t    if (h.hasOwnProperty(header)) {\n\t      //we save just because\n\t      this.globalHeaders[ header ] = h[ header ];\n\t    }\n\t  }\n\t\n\t};\n\t\n\tconnectionManager.prototype.send = function( connID, method, data ){\n\t\n\t  if( !data ) data = null;\n\t  this.connections[ connID ].startAndSend( method, data, this.globalHeaders );\n\t\n\t};\n\t\n\t/**\n\t * This is the start of XMLHttpRequest, here we set up our\n\t * connection uid and a basic connection object that holds\n\t * basic data about this individual connection.\n\t * @param {URL} input the url you want to connect to\n\t * @returns {string} that is the ID of your connection.\n\t */\n\tconnectionManager.prototype.confConnection = function( url ){\n\t\n\t  var id = this.generateConnectionID();\n\t  this.connections[ id ] = new connection( url, id );\n\t  return this.connections[ id ];\n\t\n\t};\n\t\n\tconnectionManager.prototype.generateConnectionID = function(){\n\t\n\t  function s4() {\n\t    return Math.floor((1 + Math.random()) * 0x10000)\n\t      .toString(16)\n\t      .substring(1);\n\t  }\n\t  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n\t    s4() + '-' + s4() + s4() + s4();\n\t\n\t};\n\t\n\tmodule.exports = connectionManager;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tvar connection = function( url, id ){\n\t\n\t  this.UNSENT = 0;\n\t  this.OPENED = 1;\n\t  this.HEADERS_RECEIVED = 2;\n\t  this.LOADING = 3;\n\t  this.DONE = 4;\n\t  this.url =  url;\n\t  this.id = id;\n\t  this.data;\n\t  this.encoding;\n\t  this.async =  true;\n\t  this.tempHeaders =  {};\n\t  this.xhr =  this.checkXHR();\n\t  this.data = new FormData();\n\t  this.lastTimeOfUse = 0;\n\t\n\t  this.setListeners();\n\t\n\t};\n\t\n\tconnection.prototype.startAndSend = function( method, data, headers ){\n\t\n\t  this.formatAsFormData( data );\n\t  this.xhr.open( method, this.url, true );//always async\n\t  this._addTempHeader( headers );\n\t  this._addTempHeader( this.tempHeaders );\n\t\n\t  //timestamp of last use\n\t  this.setNowLastTimeOfUse();\n\t\n\t  this.xhr.send( this.data );\n\t\n\t};\n\t\n\tconnection.prototype.formatAsFormData = function( data ){\n\t\n\t  for ( var member in data ) {\n\t    if (data.hasOwnProperty( member )) {\n\t\n\t      this.data.append( member, data[ member ] );\n\t\n\t    }\n\t  }\n\t\n\t};\n\t\n\t\n\tconnection.prototype.setNowLastTimeOfUse = function(){\n\t\n\t  var date = Date.now();\n\t  this.lastTimeOfUse = date;\n\t\n\t};\n\t\n\tconnection.prototype.addTxtFileFromString = function( name, str ){\n\t\n\t  if( typeof str !== 'string' )\n\t    throw 'Use string for this method';\n\t\n\t  var blob = new Blob([str], { type: \"text/plain\" });\n\t\n\t  this.data.append( name, blob );\n\t\n\t  return this;\n\t\n\t};\n\t\n\tconnection.prototype.addImgFileFromArr = function( name, arr, type ){\n\t\n\t  if( arr instanceof Array )\n\t    throw 'Use an array for this method';\n\t\n\t  if( typeof type !== 'string' )\n\t    throw 'use a string for the MIME type, like image/jpeg';\n\t\n\t  var blob = new Blob([arr], { type: ( type )? type: 'image/jpeg' });\n\t\n\t  this.data.append( name, blob );\n\t\n\t  return this;\n\t\n\t};\n\t\n\tconnection.prototype.addTempHeader = function( h ){\n\t\n\t  if( !h )\n\t    throw 'grow a pair... name, value needed to set a temporal header for this onnection';\n\t\n\t  for (var header in h) {\n\t    if (h.hasOwnProperty(header)) {\n\t      //we save just because\n\t      this.tempHeaders[ header ] = h[ header ];\n\t    }\n\t  }\n\t\n\t  //console.log( this.tempHeaders )\n\t  return this;\n\t\n\t};\n\t\n\tconnection.prototype._addTempHeader = function( h ){\n\t\n\t  if( !h )\n\t    throw 'grow a pair... name, value needed to set a temporal header for this onnection';\n\t\n\t  for (var header in h) {\n\t    if (h.hasOwnProperty(header)) {\n\t      //we save just because\n\t      this.xhr.setRequestHeader( header, h[ header ] );\n\t    }\n\t  }\n\t\n\t  //console.log( this.tempHeaders )\n\t  return this;\n\t\n\t};\n\t\n\t/**\n\t * This method is yet to be defined, we know that you can send\n\t * multipart encoded data using FormData API, so.... maybe encoding for this API\n\t * goes that way: set a variable encoding just to use FormData API\n\t * @param {string} input supported encoding type\n\t */\n\tconnection.prototype.setEncoding = function( enc ) {\n\t\n\t  return this;\n\t};\n\t\n\t\n\tconnection.prototype.checkXHR = function() {\n\t\n\t  if (window.XMLHttpRequest) {\n\t    // Chrome, Firefox, IE7+, Opera, Safari\n\t    return new XMLHttpRequest();\n\t  }\n\t  // IE6\n\t  try {\n\t    // The latest stable version. It has the best security, performance,\n\t    // reliability, and W3C conformance. Ships with Vista, and available\n\t    // with other OS's via downloads and updates.\n\t    return new ActiveXObject('MSXML2.XMLHTTP.6.0');\n\t  } catch (e) {\n\t\n\t    try {\n\t      // The fallback.\n\t      return new ActiveXObject('MSXML2.XMLHTTP.3.0');\n\t    } catch (e) {\n\t      //alert('This browser is not AJAX enabled.');\n\t      return null;\n\t    }\n\t\n\t  }\n\t};\n\t\n\tconnection.prototype.setListeners = function(){\n\t\n\t  this.xhr.addEventListener( 'readystatechange', this.readystatechange.bind(this) );\n\t  this.xhr.addEventListener( \"progress\", this._progress.bind(this) );\n\t  this.xhr.addEventListener( \"load\", this._load.bind(this) );\n\t  this.xhr.addEventListener( \"error\", this._error.bind(this) );\n\t  this.xhr.addEventListener( \"abort\", this._abort.bind(this) );\n\t\n\t};\n\t\n\tconnection.prototype.readystatechange = function( context ){\n\t\n\t    if (this.xhr.readyState === this.DONE && this.xhr.status === 200) {\n\t       // Action to be performed when the document is read;\n\t       this._response( this.xhr.responseText );\n\t    }else{\n\t      //not yet rdy\n\t      //console.log( this.xhr.readyState, this.xhr.status )\n\t    }\n\t};\n\t\n\tconnection.prototype._response = function( data ){\n\t  this.response( data );\n\t};\n\tconnection.prototype.response = function( data ){};\n\t\n\tconnection.prototype._progress = function( e ){\n\t  var percentComplete;\n\t  if (e.lengthComputable) {\n\t    percentComplete = e.loaded / e.total;\n\t  } else {\n\t    // Unable to compute progress information since the total size is unknown\n\t  }\n\t  this.progress( percentComplete );\n\t};\n\tconnection.prototype.progress = function( percentComplete ){};\n\t\n\tconnection.prototype._load = function( e ){\n\t\n\t  this.load( e );\n\t};\n\tconnection.prototype.load = function( e ){};\n\t\n\tconnection.prototype._error = function( e ){\n\t\n\t  this.error( e );\n\t};\n\tconnection.prototype.error = function( e ){};\n\t\n\tconnection.prototype._abort = function( e ){\n\t\n\t  this.abort( e );\n\t};\n\tconnection.prototype.abort = function( e ){};\n\t\n\tmodule.exports = connection;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// war.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 06e7dfc74c2f8af9cf08","var war = require('./war/connectionManager.js');\nwar = new war();\nmodule.exports = war;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","// onloadstart\tloadstart\n// onprogress\tprogress\n// onabort\tabort\n// onerror\terror\n// onload\tload\n// ontimeout\ttimeout\n// onloadend\tloadend\n\nvar connection = require('./connection.js');\n\nvar connectionManager = function(){\n\n  this.globalHeaders = {};\n  this.methods = [ 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD' ];\n  this.connections = {};\n\n  for (var i = 0; i < this.methods.length; i++) {\n    this[ this.methods[i] ] = (function( method ){\n      return function( connID, data ){\n        this.send( connID, method, data );\n      };\n    }.bind(this))( this.methods[i] );\n  }\n\n};\n\nconnectionManager.prototype.setGlobalHeaders = function( h ){\n\n  if( !h )\n    throw 'grow a pair... name, value needed to set a temporal header for this connection';\n\n  for (var header in h) {\n    if (h.hasOwnProperty(header)) {\n      //we save just because\n      this.globalHeaders[ header ] = h[ header ];\n    }\n  }\n\n};\n\nconnectionManager.prototype.send = function( connID, method, data ){\n\n  if( !data ) data = null;\n  this.connections[ connID ].startAndSend( method, data, this.globalHeaders );\n\n};\n\n/**\n * This is the start of XMLHttpRequest, here we set up our\n * connection uid and a basic connection object that holds\n * basic data about this individual connection.\n * @param {URL} input the url you want to connect to\n * @returns {string} that is the ID of your connection.\n */\nconnectionManager.prototype.confConnection = function( url ){\n\n  var id = this.generateConnectionID();\n  this.connections[ id ] = new connection( url, id );\n  return this.connections[ id ];\n\n};\n\nconnectionManager.prototype.generateConnectionID = function(){\n\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n    s4() + '-' + s4() + s4() + s4();\n\n};\n\nmodule.exports = connectionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/war/connectionManager.js\n// module id = 1\n// module chunks = 0","var connection = function( url, id ){\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n  this.url =  url;\n  this.id = id;\n  this.data;\n  this.encoding;\n  this.async =  true;\n  this.tempHeaders =  {};\n  this.xhr =  this.checkXHR();\n  this.data = new FormData();\n  this.lastTimeOfUse = 0;\n\n  this.setListeners();\n\n};\n\nconnection.prototype.startAndSend = function( method, data, headers ){\n\n  this.formatAsFormData( data );\n  this.xhr.open( method, this.url, true );//always async\n  this._addTempHeader( headers );\n  this._addTempHeader( this.tempHeaders );\n\n  //timestamp of last use\n  this.setNowLastTimeOfUse();\n\n  this.xhr.send( this.data );\n\n};\n\nconnection.prototype.formatAsFormData = function( data ){\n\n  for ( var member in data ) {\n    if (data.hasOwnProperty( member )) {\n\n      this.data.append( member, data[ member ] );\n\n    }\n  }\n\n};\n\n\nconnection.prototype.setNowLastTimeOfUse = function(){\n\n  var date = Date.now();\n  this.lastTimeOfUse = date;\n\n};\n\nconnection.prototype.addTxtFileFromString = function( name, str ){\n\n  if( typeof str !== 'string' )\n    throw 'Use string for this method';\n\n  var blob = new Blob([str], { type: \"text/plain\" });\n\n  this.data.append( name, blob );\n\n  return this;\n\n};\n\nconnection.prototype.addImgFileFromArr = function( name, arr, type ){\n\n  if( arr instanceof Array )\n    throw 'Use an array for this method';\n\n  if( typeof type !== 'string' )\n    throw 'use a string for the MIME type, like image/jpeg';\n\n  var blob = new Blob([arr], { type: ( type )? type: 'image/jpeg' });\n\n  this.data.append( name, blob );\n\n  return this;\n\n};\n\nconnection.prototype.addTempHeader = function( h ){\n\n  if( !h )\n    throw 'grow a pair... name, value needed to set a temporal header for this onnection';\n\n  for (var header in h) {\n    if (h.hasOwnProperty(header)) {\n      //we save just because\n      this.tempHeaders[ header ] = h[ header ];\n    }\n  }\n\n  //console.log( this.tempHeaders )\n  return this;\n\n};\n\nconnection.prototype._addTempHeader = function( h ){\n\n  if( !h )\n    throw 'grow a pair... name, value needed to set a temporal header for this onnection';\n\n  for (var header in h) {\n    if (h.hasOwnProperty(header)) {\n      //we save just because\n      this.xhr.setRequestHeader( header, h[ header ] );\n    }\n  }\n\n  //console.log( this.tempHeaders )\n  return this;\n\n};\n\n/**\n * This method is yet to be defined, we know that you can send\n * multipart encoded data using FormData API, so.... maybe encoding for this API\n * goes that way: set a variable encoding just to use FormData API\n * @param {string} input supported encoding type\n */\nconnection.prototype.setEncoding = function( enc ) {\n\n  return this;\n};\n\n\nconnection.prototype.checkXHR = function() {\n\n  if (window.XMLHttpRequest) {\n    // Chrome, Firefox, IE7+, Opera, Safari\n    return new XMLHttpRequest();\n  }\n  // IE6\n  try {\n    // The latest stable version. It has the best security, performance,\n    // reliability, and W3C conformance. Ships with Vista, and available\n    // with other OS's via downloads and updates.\n    return new ActiveXObject('MSXML2.XMLHTTP.6.0');\n  } catch (e) {\n\n    try {\n      // The fallback.\n      return new ActiveXObject('MSXML2.XMLHTTP.3.0');\n    } catch (e) {\n      //alert('This browser is not AJAX enabled.');\n      return null;\n    }\n\n  }\n};\n\nconnection.prototype.setListeners = function(){\n\n  this.xhr.addEventListener( 'readystatechange', this.readystatechange.bind(this) );\n  this.xhr.addEventListener( \"progress\", this._progress.bind(this) );\n  this.xhr.addEventListener( \"load\", this._load.bind(this) );\n  this.xhr.addEventListener( \"error\", this._error.bind(this) );\n  this.xhr.addEventListener( \"abort\", this._abort.bind(this) );\n\n};\n\nconnection.prototype.readystatechange = function( context ){\n\n    if (this.xhr.readyState === this.DONE && this.xhr.status === 200) {\n       // Action to be performed when the document is read;\n       this._response( this.xhr.responseText );\n    }else{\n      //not yet rdy\n      //console.log( this.xhr.readyState, this.xhr.status )\n    }\n};\n\nconnection.prototype._response = function( data ){\n  this.response( data );\n};\nconnection.prototype.response = function( data ){};\n\nconnection.prototype._progress = function( e ){\n  var percentComplete;\n  if (e.lengthComputable) {\n    percentComplete = e.loaded / e.total;\n  } else {\n    // Unable to compute progress information since the total size is unknown\n  }\n  this.progress( percentComplete );\n};\nconnection.prototype.progress = function( percentComplete ){};\n\nconnection.prototype._load = function( e ){\n\n  this.load( e );\n};\nconnection.prototype.load = function( e ){};\n\nconnection.prototype._error = function( e ){\n\n  this.error( e );\n};\nconnection.prototype.error = function( e ){};\n\nconnection.prototype._abort = function( e ){\n\n  this.abort( e );\n};\nconnection.prototype.abort = function( e ){};\n\nmodule.exports = connection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/war/connection.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}